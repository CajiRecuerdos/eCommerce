{"ast":null,"code":"// Debemos definir el estado inicial de nuestro ejercicio\n\nimport { TYPES } from '../actions/carritoActions';\nimport carrito from \"../ProductosDB.json\";\nexport const shopInitialState = {\n  // lista de productos del backend\n  products: carrito,\n  // aqui vamos a guardar los productos que agreguemos\n  newCart: [],\n  total: 0\n};\n\n// Creamos la logica, cuando llamemos a los types ¿Que va hacer tu codigo?\n// las funciones reductoras reciben siempre un estado y las acciones a cumplir\n\nexport function shopReducer(state, action) {\n  switch (action.type) {\n    case TYPES.ADD_TO_CART:\n      {\n        let newItem = state.products.find(product => product.id === action.payload);\n\n        /// para que retorne con el indice de cantidad\n\n        let iteminCart = state.newCart.find(item => item.id === newItem.id);\n        return iteminCart ? {\n          ...state,\n          newCart: state.newCart.map(item => item.id === newItem.id ? {\n            ...item,\n            cantidad: item.cantidad + 1\n          } : item)\n        } : {\n          ...state,\n          newCart: [...state.newCart, {\n            ...newItem,\n            cantidad: 1\n          }]\n        };\n      }\n    case TYPES.REMOVE_ONE_FROM_CART:\n      {\n        let itemToDelete = state.newCart.find(item => item.id === action.payload);\n        return itemToDelete.cantidad > 1 ? {\n          ...state,\n          newCart: state.newCart.map(item => item.id === action.payload ? {\n            ...item,\n            cantidad: item.cantidad - 1\n          } : item)\n        } : {\n          ...state,\n          newCart: state.newCart.filter(item => item.id !== action.payload)\n        };\n      }\n    case TYPES.CLEAR_CART:\n      {\n        return shopInitialState;\n      }\n    default:\n      return state;\n  }\n}","map":{"version":3,"names":["TYPES","carrito","shopInitialState","products","newCart","total","shopReducer","state","action","type","ADD_TO_CART","newItem","find","product","id","payload","iteminCart","item","map","cantidad","REMOVE_ONE_FROM_CART","itemToDelete","filter","CLEAR_CART"],"sources":["D:/3. Estudio/MinTIC/Ciclo 4/1. PROYECTO/eCommerce2/eCommerce-development/interfaz2/src/reducers/carritoReducer.js"],"sourcesContent":["// Debemos definir el estado inicial de nuestro ejercicio\r\n\r\nimport { TYPES } from '../actions/carritoActions';\r\nimport carrito from \"../ProductosDB.json\"\r\n\r\nexport const shopInitialState = {\r\n    // lista de productos del backend\r\n    products: carrito,\r\n    // aqui vamos a guardar los productos que agreguemos\r\n    newCart: [],\r\n    \r\n    total: 0,\r\n}\r\n\r\n// Creamos la logica, cuando llamemos a los types ¿Que va hacer tu codigo?\r\n// las funciones reductoras reciben siempre un estado y las acciones a cumplir\r\n\r\nexport function shopReducer(state, action) {\r\n    \r\n    switch (action.type) {\r\n        case TYPES.ADD_TO_CART: {\r\n            let newItem = state.products.find(\r\n                (product) => product.id === action.payload);\r\n\r\n            /// para que retorne con el indice de cantidad\r\n\r\n            let iteminCart = state.newCart.find((item) => item.id === newItem.id)\r\n\r\n            return iteminCart\r\n                ? {\r\n                    ...state,\r\n                    newCart: state.newCart.map((item) =>\r\n                        item.id === newItem.id\r\n                            ? { ...item, cantidad: item.cantidad + 1 }\r\n                            : item),\r\n                }\r\n                : {\r\n                    ...state,\r\n                    newCart: [...state.newCart, {...newItem, cantidad: 1}],\r\n                }\r\n\r\n        }\r\n        case TYPES.REMOVE_ONE_FROM_CART: {\r\n            let itemToDelete = state.newCart.find((item) => item.id === action.payload);\r\n            return itemToDelete.cantidad > 1?{\r\n                ...state,\r\n                newCart: state.newCart.map(item => item.id === action.payload\r\n                    ?{...item, cantidad: item.cantidad - 1}:\r\n                    item\r\n                    ),\r\n            }:{\r\n                ...state,\r\n                newCart: state.newCart.filter((item) => item.id !== action.payload),\r\n            };\r\n        }\r\n        case TYPES.CLEAR_CART: {\r\n            return shopInitialState;\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n\r\n}"],"mappings":"AAAA;;AAEA,SAASA,KAAK,QAAQ,2BAA2B;AACjD,OAAOC,OAAO,MAAM,qBAAqB;AAEzC,OAAO,MAAMC,gBAAgB,GAAG;EAC5B;EACAC,QAAQ,EAAEF,OAAO;EACjB;EACAG,OAAO,EAAE,EAAE;EAEXC,KAAK,EAAE;AACX,CAAC;;AAED;AACA;;AAEA,OAAO,SAASC,WAAW,CAACC,KAAK,EAAEC,MAAM,EAAE;EAEvC,QAAQA,MAAM,CAACC,IAAI;IACf,KAAKT,KAAK,CAACU,WAAW;MAAE;QACpB,IAAIC,OAAO,GAAGJ,KAAK,CAACJ,QAAQ,CAACS,IAAI,CAC5BC,OAAO,IAAKA,OAAO,CAACC,EAAE,KAAKN,MAAM,CAACO,OAAO,CAAC;;QAE/C;;QAEA,IAAIC,UAAU,GAAGT,KAAK,CAACH,OAAO,CAACQ,IAAI,CAAEK,IAAI,IAAKA,IAAI,CAACH,EAAE,KAAKH,OAAO,CAACG,EAAE,CAAC;QAErE,OAAOE,UAAU,GACX;UACE,GAAGT,KAAK;UACRH,OAAO,EAAEG,KAAK,CAACH,OAAO,CAACc,GAAG,CAAED,IAAI,IAC5BA,IAAI,CAACH,EAAE,KAAKH,OAAO,CAACG,EAAE,GAChB;YAAE,GAAGG,IAAI;YAAEE,QAAQ,EAAEF,IAAI,CAACE,QAAQ,GAAG;UAAE,CAAC,GACxCF,IAAI;QAClB,CAAC,GACC;UACE,GAAGV,KAAK;UACRH,OAAO,EAAE,CAAC,GAAGG,KAAK,CAACH,OAAO,EAAE;YAAC,GAAGO,OAAO;YAAEQ,QAAQ,EAAE;UAAC,CAAC;QACzD,CAAC;MAET;IACA,KAAKnB,KAAK,CAACoB,oBAAoB;MAAE;QAC7B,IAAIC,YAAY,GAAGd,KAAK,CAACH,OAAO,CAACQ,IAAI,CAAEK,IAAI,IAAKA,IAAI,CAACH,EAAE,KAAKN,MAAM,CAACO,OAAO,CAAC;QAC3E,OAAOM,YAAY,CAACF,QAAQ,GAAG,CAAC,GAAC;UAC7B,GAAGZ,KAAK;UACRH,OAAO,EAAEG,KAAK,CAACH,OAAO,CAACc,GAAG,CAACD,IAAI,IAAIA,IAAI,CAACH,EAAE,KAAKN,MAAM,CAACO,OAAO,GACxD;YAAC,GAAGE,IAAI;YAAEE,QAAQ,EAAEF,IAAI,CAACE,QAAQ,GAAG;UAAC,CAAC,GACvCF,IAAI;QAEZ,CAAC,GAAC;UACE,GAAGV,KAAK;UACRH,OAAO,EAAEG,KAAK,CAACH,OAAO,CAACkB,MAAM,CAAEL,IAAI,IAAKA,IAAI,CAACH,EAAE,KAAKN,MAAM,CAACO,OAAO;QACtE,CAAC;MACL;IACA,KAAKf,KAAK,CAACuB,UAAU;MAAE;QACnB,OAAOrB,gBAAgB;MAC3B;IACA;MACI,OAAOK,KAAK;EAAC;AAGzB"},"metadata":{},"sourceType":"module"}